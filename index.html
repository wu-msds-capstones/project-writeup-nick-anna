<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.53">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Slow Drip or All at Once?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="capstone_files/libs/clipboard/clipboard.min.js"></script>
<script src="capstone_files/libs/quarto-html/quarto.js"></script>
<script src="capstone_files/libs/quarto-html/popper.min.js"></script>
<script src="capstone_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="capstone_files/libs/quarto-html/anchor.min.js"></script>
<link href="capstone_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="capstone_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="capstone_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="capstone_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="capstone_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="capstone_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="capstone_files/libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">


</head>

<body class="fullcontent">

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Slow Drip or All at Once?</h1>
            <p class="subtitle lead">How does the staying power of a television show change based on the release schedule of the show?</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-contents">
               <p>Nick Brooks </p>
               <p>Anna Clarkson </p>
            </div>
    </div>
      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Binge-watching has been around for almost two decades, having been popularized by the availability (and accessibility) of TV shows like <em>Grey’s Anatomy</em> and <em>Breaking Bad</em> on streaming platforms like Netflix, Hulu, and Amazon Prime Video starting in the mid- to late 2000s. However, it really took off in 2013 when Netflix began releasing original content, starting with <em>House of Cards</em> and followed later that year by <em>Orange is the New Black</em>. Netflix started the practice of releasing all episodes of a season at once, a sharp departure from the standard weekly episodes. They continue to release most of their content this way, with a few exceptions (<em>Love is Blind</em> and season 3 of <em>Bridgerton</em>, notably). The public seemed to love it because they could watch at their own pace and didn’t have to wait a week after a mid-season cliff-hanger.</p>
<p>Shows like <em>Succession</em>, <em>The Last of Us</em>, and <em>The White Lotus</em>, all of which aired weekly on HBO at the same time they were released on HBO Max (later Max), created intense online discourse and reignited appointment television for an hour each Sunday. This provided not only a way for viewers to connect with each other, but also built momentum and caused the shows to stay in the public discourse for as many weeks as they aired.</p>
<p>As more streaming platforms came onto the market, so did more methods of releasing original content. While some shows are still released all at once (the “binge model”), many are released weekly, with some providing two or three episodes to start before transitioning to one episode a week. Some shows will also be released in batches of two episodes every week. For example, all 3 seasons of The Bear on Hulu have been released all at once, while season 1 of Shogun premiered with the first two episodes at once and then weekly.</p>
<p>With the rise of social media, platforms like Twitter became an important place to discuss TV shows with fellow viewers and get recommendations, later followed by TikTok. This project will seek to answer the question “<em>Does the release schedule of a show (weekly, in parts, or all at once) impact their staying power?</em>” Of particular interest is how shows perform on weekly Nielsen charts - both overall and by streaming platform - and their interest over time on Google Trends.</p>
</section>
<section id="background" class="level1">
<h1>Background</h1>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<p>In order to answer our question of interest, we had to gather a large amount of data from a wide number of various sources and databases. Unless mentioned otherwise, all of the data that was collected was data specifically about the US. Google Trends data and the ratings data all reflect the United States ratings and values; we decided to exclude worldwide ratings as we are most interested in the US Market.</p>
<p><strong>Google Trends</strong><br>
Google Trends data was gathered for each show, movie, or special that appeared on any of the ratings lists that were collected. This data was gathered for a timeframe of the last 5 years for each show, regardless of when the show premiered in order to keep our data consistent. The data for each show was downloaded in a CSV file from the Google Trends website, with two columns: Date and Rating. The ratings are on a normalized scale, where 100 is equal to the point in time that the term was searched for most often, and 0 means that the term was not searched enough to crack the threshold.</p>
<p>The main issue to overcome was in getting the ratings associated with the show, as the show was not included in the CSV file. This was solved by naming each CSV file after the show or movie, and then adding a column of the file name so that we can match the ratings with the show titles.</p>
<p>In order to process such large quantities of CSV files, we organized them into folders based on the shows’ streaming platform. For example, the ‘Netflix’ folder contained the Google Trends CSVs for the shows <em>Stranger Things</em>, <em>Bridgerton</em>, and <em>The Crown</em>, among others. We then set up a function in R to loop over the folders of CSVs, which ingested all of the data, added the show’s name to the dataset as a new column, and then combined all rows together. Therefore, we were left with a single CSV of Google Trends data instead of hundreds of individual CSVs.</p>
<p><strong>Nielsen Weekly Streaming Ratings</strong><br>
Nielsen weekly steaming ratings (see current week <a href="https://www.nielsen.com/data-center/top-ten/">here</a>) data was collected for as far back as they go, which is September 2020. Nielsen’s website only offers the most recent release, with no archive, so they were gathered from Variety articles (<a href="https://variety.com/2024/tv/news/nielsen-top-10-ratings-streaming-1235693657/">example</a>) or the TV Grim Reaper on Twitter/X (<a href="https://x.com/TVGrimReaper/status/1751995525032034443">example</a>). We specifically gathered the Top 10 data for Original Content; as we are mainly interested in how a streaming show’s release schedule influences its popularity, information on acquired shows that were released in other means was not information that we were interested in.</p>
<p>The biggest challenge that we encountered in processing the Nielsen Weekly Streaming data came from the form that the data was collected in. We were unable to find a CSV download for the Nielsen data (that we wouldn’t have to pay for), so we took screenshots of the Nielsen Top 10 Weekly data. Each screenshot contained the following information: the week that the ratings were from, show rank (1-10), the show’s name, the show’s SVOD Provider (streaming platform), the total number of episodes of the show, and the number of minutes that the program was watched in the past week.</p>
<p>As we had over 190 screenshots of Nielsen data, we did not wish to process this data manually. As such, we looked for ways to process these screenshots using programmatic means. A few APIs were tested to determine which could process the data the most successfully, with AWS being the best. All the images were fed through the Amazon Textract tool and downloaded as ZIP files, which contained a CSV. R was used to unzip the folders, clean the data, and merge the files together into a single CSV file. This CSV contained all of the weekly Nielsen data that was collected, with a column for the date of the rankings in order to keep each week separate.</p>
<p><strong>TV Grim Reaper Weekly Streaming Ratings</strong><br>
In addition to Nielsen’s overall ratings that encompass all of the major streaming platforms, Nielsen also releases weekly top 10 ratings for each streaming platform. The Nielsen top 10 lists for individual streaming platforms came from the TV Grim Reaper on Twitter/X (<a href="https://x.com/TVGrimReaper/status/1787594943994941612">example</a>). The TV Grim Reaper posted these screenshots starting from around June 2023 to April of 2024, so we have roughly one year’s worth of data to work with.</p>
<p>In total, we gathered ratings for the platforms: Amazon Prime Video, Apple TV+, Disney+ and Hulu. We did not gather data for Netflix (see next section), and did not gather data for Peacock or Paramount+ as these platforms’ top 10 data was not captured by the TV Grim Reaper and we were unable to find any alternative means of collecting this data.</p>
<p>Screenshots were taken of each tweet, and like the Nielsen weekly ratings, were then fed through the Amazon Textract API from AWS. R was again used to unzip the folders, clean the data, and merge the files together (one for each platform).</p>
<p><strong>Netflix Weekly Top 10 Streaming Ratings</strong><br>
The reason that we did not gather Netflix Top 10 data from the TV Grim Reaper is because Netflix is the only streaming platform that offers a CSV download (<a href="https://www.netflix.com/tudum/top10/united-states/tv?week=2024-07-21">link</a>) of its entire Weekly Top 10 history (starting from August 2021 - present day). This was very beneficial to us, as it not only covered a longer period of time than the TV Grim Reaper ratings did, but it also came in a CSV download with all of the key variables and information that we were interested in, such as date, ranking, and show name.</p>
<p><strong>FlixPatrol Yearly Streaming Ratings</strong><br>
FlixPatrol is a movie and TV ratings compiler that provides an API to get lists of ratings, with options to filter by show type, streaming platform, countries, years, and many more options. We gathered the yearly ratings for the eight main streaming platforms that we are analyzing (Amazon Prime, Apple TV, Disney +, HBO Max, Hulu, Netflix, Paramount+, Peacock) for the years of 2021-2024 (which overlaps with our weekly streaming ratings data). We had no real issues getting these into a good format as the API allowed for specifying which columns we were interested in (show, platform, rating, and date), and offered CSV downloads of our queries.</p>
<p><strong>Show Release Information</strong><br>
One of the main components of our project involves the release schedule of individual shows. To obtain this information, we compiled a list of all the shows we had data for, and using Wikipedia articles for each platform (<a href="https://en.wikipedia.org/wiki/List_of_Amazon_Prime_Video_original_programming">example</a>), got the number of seasons for each show, as well as the release schedule for each season.</p>
<p>We binned the releases into three separate categories: all at once, hybrid, and weekly. All at once shows were shows whose entire seasons were released all at the same time. Weekly shows were shows whose episodes were released at a rate of one per week. Hybrid shows were shows whose episodes were released in some combination of all at once and weekly. A good example of this is the first season of Ted Lasso. The first three episodes were released all at once, and then the rest of the season was released at a rate of one episode per week.</p>
<p>We had to organize the show release by season because there are some shows, such as <em>Bridgerton</em>, whose release schedule changed over the course of the show’s lifetime. Seasons 1 and 2 of <em>Bridgerton</em> both released their entire seasons all at once, whereas Season 3 of <em>Bridgerton</em> released in two four-episode batches. As such, it would be misleading to classify <em>Bridgerton</em> as either a strictly ‘all at once’ or strictly ‘hybrid’ release schedule. Therefore, we decided to include each individual season to account for these scenarios of release format changes.</p>
<p>An argument can be made that Wikipedia’s information could be inaccurate. However, it was the only source that we could find that contained the release information for each individual episode of a show, whereas other sources would only contain when the season was released. Meaning, these sources would not tell us if a show was released weekly, all at once, or in a hybrid format. Furthermore, Wikipedia’s community of editors actively works to correct errors and ensure accuracy, especially within heavily trafficked articles such as popular TV shows. As such, after weighing the pros and cons, we decided we were comfortable with the potential risks of inaccuracy and decided to proceed with Wikipedia as a source of reliable information.</p>
<p>We additionally gathered whether the show was original content to the streaming platform or acquired content from a third party source. As we are most interested in the release schedule of streaming shows, acquired shows’ release schedules did not pertain to our questions of interest and as such, we excluded these shows from our analysis.</p>
<p><strong>Show Genre and Language Information</strong><br>
Another variable we were interested in was the genre of a show, and how the show’s genre can affect its popularity. To gather this information, we once again turned to Wikipedia. The show genres that are listed on Wikipedia can be extremely specific, such as the genre for the Amazon Prime Video show Gen V being listed as ‘superhero teen drama’. As one can imagine, that was the only show in the entire dataset that had that specific genre. Therefore, we knew that using the genres as they were listed on Wikipedia would not be sufficient for our needs and decided to bin the genres into their main categories.</p>
<p>We decided to bin the shows into three different genre categories: drama, comedy, and docuseries. Any show whose genre included the word ‘comedy’, ‘drama’, or ‘docuseries’ was put into its respective category. From there, we were left with a large list of genres that we classified into the bins based on how we felt they best fit. For docuseries, we included any genre that was non-fiction or depicted real world events. This included true crime documentaries, reality competition shows, and game shows. For drama, we included any genre that was classified as a genre that is typically dramatic, such as horror, thriller, and telenovela. For comedy, we included any genre that is typically lighthearted, such as sitcoms, children’s shows, and mockumentary.</p>
<p>One important caveat: each show was classified as one of the three genre categories with only one exception. There is a small subset of shows in the dataset whose genre lists both Comedy and Drama, such as the show <em>The Bear</em>. <em>The Bear</em>’s genre was listed as ‘comedy drama’, and as such, it felt disingenuous to assign the show to a single bin. Therefore, if a show’s genre specifically had both of the words ‘comedy’ and ‘drama’, we classified the show as both a comedy and a drama. As we were essentially duplicating these shows, we separated the binned genres into a different table in our database so we don’t have duplicate shows in the shows table and can maintain having a single row for each show in our shows table.</p>
<p>We also gathered information on the language of the show. As mentioned above, we only collected the ratings for the US specifically, but as we know, the US is a melting pot of different cultures and backgrounds. This meant that there were a small, but not insignificant number of shows in our dataset that are in a foreign language. So we decided to also gather language data from Wikipedia while we were gathering the genre information.</p>
</section>
<section id="data" class="level1">
<h1>Data</h1>
<p>We decided to store our data in 3NF, and as such, assigned unique ID numbers to each show and streaming platform in the ratings. The most time consuming and tedious part of the project was in getting all of the show titles in a consistent format so that we could assign them all IDs. Many shows were listed in multiple different ways in the various ratings; for example, the Netflix show ‘Formula 1: Drive to Survive’ was in the datasets as ‘Formula 1: Drive to Survive’, ‘FORMULA 1: DRIVE SURVIVE’, and ‘Formula One: Drive…’. This was true for many of the shows in the various datasets, so in order to ensure consistency for joining purposes, we went through the datasets and set each show name to a consistent format. This ended up being a pretty considerable effort, taking a few days’ worth of work to complete. But once we were finished, we were able to easily and consistently join our datasets together and change the show names to show ids.</p>
<p>The way that we structured our database tables is shown in the ERD Diagram of <strong>Figure 1</strong>.</p>
<p><img src="images/erd.png" class="img-fluid" width="780"> <em><br>
<strong>Figure 1</strong>: ERD Diagram of Database Design and Structure</em></p>
<p>We use the show_id as our main connecting piece, allowing us to connect our shows table with the various ratings tables, the gtrends table (containing Google Trends data), and the releaseinfo and binned_genres tables.</p>
<p>Instead of having unique Primary Keys for each table, we primarily use compound keys as unique identifiers for each of our tables. Only the shows and platforms tables have single value primary keys. Every other table has a compound primary key. The compound keys were chosen to have a unique identifier that we could use to identify each row. For example, the netflixtop10 table’s compound key consists of the show_id, date, and season_title. This is because Netflix’s Top 10 data breaks down a show by season, so a single show could appear on the same week’s top 10 list multiple times. An example of this is Bridgerton. The Netflix Top 10 list for the week of June 6, 2024 contains Bridgerton Season 3, Bridgerton Season 2, and Bridgerton Season 1. As such, a compound key of just the show_id and date would not create a unique compound key. Therefore, season_title was also included to differentiate between the different seasons of a show.</p>
<p>The season_number was included in the compound key of the releaseinfo table for similar reasons; as the release schedule for a show can change over the lifetime of the show, we needed to include the season_number to the compound key alongside the show_id to ensure that each row had a unique identifier.</p>
<p>Most of the other tables such as gtrends, reaperratings, yearlyratings, and nielsenratings use a compound key of just the date and show_id as they do not differentiate between seasons, and therefore each show would have at maximum one data point per week, making our compound keys unique for these tables.</p>
<p>The binned_genres table required including both the show_id and the binned_genre as part of the compound key. This is due to the fact that, as mentioned in the S<strong>how Genre</strong> section, there are a small number of shows whose genre listed both ‘comedy’ and ‘drama’, and as such, we classified them as both. Therefore, within the binned_genres table, there are a few show_ids that are repeated, so we must additionally include the binned_genre column in our compound key to ensure that each row is unique.</p>
</section>
<section id="results" class="level1">
<h1>Results</h1>
</section>
<section id="conclusions" class="level1">
<h1>Conclusions</h1>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>